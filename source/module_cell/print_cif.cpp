#include "module_cell/unitcell.h"
#include <cmath>   // for std::pow and std::round

// Function to calculate the greatest common divisor
long long gcd_func(long long a, long long b) {
    return b == 0 ? a : gcd_func(b, a % b);
}

std::string floatToFraction(double number, double accuracy = 1e-9) {
    // Determine the sign of the number
    int sign = number < 0 ? -1 : 1;
    number = std::abs(number);

    // The maximum denominator is set to a large number to ensure precision
    const long long max_denominator = 1000000;

    // Start with a denominator of 1
    long long denominator = 1;
    long long numerator = std::round(number * denominator);

    // Keep increasing the denominator to find a better approximation
    double error;
    do {
        denominator *= 10;
        numerator = std::round(number * denominator);
        error = std::abs(number - (double)numerator / denominator);
    } while (error > accuracy && denominator <= max_denominator);

    // Simplify the fraction by dividing both numerator and denominator by their GCD
    long long gcd = gcd_func(numerator, denominator);
    numerator /= gcd;
    denominator /= gcd;

    // Apply the sign to the numerator
    numerator *= sign;

    if (denominator == 1) {
        return std::to_string(numerator);
    } else {
        return std::to_string(numerator) + "/" + std::to_string(denominator);
    }
}

void UnitCell::print_cell_cif(const std::string& fn) const
{
    if (GlobalV::test_unitcell)
        ModuleBase::TITLE("UnitCell", "print_cell_cif");

    if (GlobalV::MY_RANK != 0)
        return; // xiaohui add 2015-03-15

    std::stringstream ss;
    ss << GlobalV::global_out_dir << fn;

    std::ofstream ofs(ss.str().c_str());
    ofs << "data_" << latName << std::endl;
    ofs << std::endl;
    // xiaohui modify 2015-03-25
    // ofs << "_audit_creation_method" << " generated by MESIA" << std::endl;
    ofs << "_audit_creation_method"
        << " generated by ABACUS" << std::endl;
    ofs << std::endl;
    ofs << "_cell_length_a " << a1.norm() * lat0 * 0.529177 << std::endl;
    ofs << "_cell_length_b " << a2.norm() * lat0 * 0.529177 << std::endl;
    ofs << "_cell_length_c " << a3.norm() * lat0 * 0.529177 << std::endl;

    // xiaohui modify and add 2014-12-21
    // ofs << "_cell_angle_alpha " << "90.00" << std::endl;
    // ofs << "_cell_angle_beta " << "90.00" << std::endl;
    // ofs << "_cell_angle_gamma " << "90.00" << std::endl;
    // xiaohui modify alpha, beta and gamma 2015-09-29
    double angle_alpha
        = acos((a2 * a3) / (a2.norm() * a3.norm())) / ModuleBase::PI * 180.0;
    double angle_beta
        = acos((a1 * a3) / (a1.norm() * a3.norm())) / ModuleBase::PI * 180.0;
    double angle_gamma
        = acos((a1 * a2) / (a1.norm() * a2.norm())) / ModuleBase::PI * 180.0;
    ofs << "_cell_angle_alpha " << angle_alpha << std::endl;
    ofs << "_cell_angle_beta " << angle_beta << std::endl;
    ofs << "_cell_angle_gamma " << angle_gamma << std::endl;
    ofs << std::endl;
    //ofs << "_symmetry_space_group_name_"
    //     << this->symm.spgname << " " << std::endl;
    ofs << "loop_" << std::endl;
        ofs << "_symmetry_equiv_pos_as_xyz" << std::endl;
    // ofs << "_symmetry_Int_Tables_number"
    //     << " " << std::endl;
    if (this->symm.symm_flag == 1)
    {
        for (int k = 0; k < this->symm.nrotk; ++k)
        {
            // Assuming ModuleBase::Matrix3 and ModuleBase::Vector3<double> are defined elsewhere
            ModuleBase::Matrix3 gmatrix = this->symm.gmatrix[k];
            ModuleBase::Vector3<double> gtrans = this->symm.gtrans[k];

            // Cast the matrix elements to int
            int e11 = static_cast<int>(gmatrix.e11);
            int e12 = static_cast<int>(gmatrix.e12);
            int e13 = static_cast<int>(gmatrix.e13);
            int e21 = static_cast<int>(gmatrix.e21);
            int e22 = static_cast<int>(gmatrix.e22);
            int e23 = static_cast<int>(gmatrix.e23);
            int e31 = static_cast<int>(gmatrix.e31);
            int e32 = static_cast<int>(gmatrix.e32);
            int e33 = static_cast<int>(gmatrix.e33);

            ofs << "'";
            // First column
            if (e11 != 0) ofs << (e11 == 1 ? "x" : (e11 == -1 ? "-x" : std::to_string(e11) + "x"));
            if (e21 != 0) ofs << (e21 > 0 ? "+" : "") << (e21 == 1 ? "y" : (e21 == -1 ? "-y" : std::to_string(e21) + "y"));
            if (e31 != 0) ofs << (e31 > 0 ? "+" : "") << (e31 == 1 ? "z" : (e31 == -1 ? "-z" : std::to_string(e31) + "z"));
            if (gtrans.x != 0) ofs << (gtrans.x > 0 ? "+" : "") << floatToFraction(gtrans.x);
            ofs << ", ";

            // Second column
            if (e12 != 0) ofs << (e12 == 1 ? "x" : (e12 == -1 ? "-x" : std::to_string(e12) + "x"));
            if (e22 != 0) ofs << (e22 > 0 ? "+" : "") << (e22 == 1 ? "y" : (e22 == -1 ? "-y" : std::to_string(e22) + "y"));
            if (e32 != 0) ofs << (e32 > 0 ? "+" : "") << (e32 == 1 ? "z" : (e32 == -1 ? "-z" : std::to_string(e32) + "z"));
            if (gtrans.y != 0) ofs << (gtrans.y > 0 ? "+" : "") << floatToFraction(gtrans.y);
            ofs << ", ";

            // Third column
            if (e13 != 0) ofs << (e13 == 1 ? "x" : (e13 == -1 ? "-x" : std::to_string(e13) + "x"));
            if (e23 != 0) ofs << (e23 > 0 ? "+" : "") << (e23 == 1 ? "y" : (e23 == -1 ? "-y" : std::to_string(e23) + "y"));
            if (e33 != 0) ofs << (e33 > 0 ? "+" : "") << (e33 == 1 ? "z" : (e33 == -1 ? "-z" : std::to_string(e33) + "z"));
            if (gtrans.z != 0) ofs << (gtrans.z > 0 ? "+" : "") << floatToFraction(gtrans.z);
            ofs << "'" << std::endl;
        }

        // Write the atom positions
        ofs << "loop_" << std::endl;
        ofs << "_atom_site_label" << std::endl;
        ofs << "_atom_site_type_symbol" << std::endl;
        ofs << "_atom_site_symmetry_multiplicity" << std::endl;
        ofs << "_atom_site_fract_x" << std::endl;
        ofs << "_atom_site_fract_y" << std::endl;
        ofs << "_atom_site_fract_z" << std::endl;
        ofs << "_atom_site_occupancy" << std::endl;

        auto inequivalent_atoms = this->symm.inequivalent_atoms();
        // ofs << std::endl;
        int iat = 0;
        for (int it = 0; it < ntype; it++) {
            for (int ia = 0; ia < atoms[it].na; ia++) {
                if (inequivalent_atoms.find(iat) == inequivalent_atoms.end())
                    continue;
                ofs << atoms[it].label << " " << atoms[it].label << " " << inequivalent_atoms[iat] << " " << atoms[it].taud[ia].x << " "
                    << atoms[it].taud[ia].y << " " << atoms[it].taud[ia].z << " " << 1
                    << std::endl;
                iat++;
            }
        }
    }
    else
    {
        ofs << "'x,y,z'" << std::endl;
        ofs << "loop_" << std::endl;
        ofs << "_atom_site_label" << std::endl;
        ofs << "_atom_site_fract_x" << std::endl;
        ofs << "_atom_site_fract_y" << std::endl;
        ofs << "_atom_site_fract_z" << std::endl;
        for (int it = 0; it < ntype; it++) {
            for (int ia = 0; ia < atoms[it].na; ia++) {
                ofs << atoms[it].label << " " << atoms[it].taud[ia].x << " "
                    << atoms[it].taud[ia].y << " " << atoms[it].taud[ia].z
                    << std::endl;
            }
        }
    }
    ofs.close();
}